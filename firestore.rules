/**
 * @fileoverview Firestore Security Rules for AssetFlow application.
 *
 * Core Philosophy:
 * This ruleset prioritizes a flexible data model for rapid prototyping while ensuring strong
 * authorization.  It assumes a collaborative environment where authenticated users can
 * read and write most data.  User profiles are strictly private and only accessible to the
 * owning user.
 *
 * Data Structure:
 * - /users/{userId}: Stores private user profile data. Only the owning user can read/write.
 * - /assets/{assetId}: Stores shared asset data. Any authenticated user can read/write.
 * - /categories/{categoryId}: Stores shared asset categories. Any authenticated user can read/write.
 * - /locations/{locationId}: Stores shared asset locations. Any authenticated user can read/write.
 * - /history/{historyId}: Stores the global asset history log. Any authenticated user can read/write.
 *
 * Key Security Decisions:
 * - Public read access to /assets, /categories, /locations, and /history collections.
 * - User-owned, private access to /users/{userId} collection.
 * - No user listing is allowed (to protect privacy).
 * - All writes are authenticated.
 *
 * Denormalization for Authorization:
 *  - The current data model does not require denormalization. All ownership and access decisions
 *    are based on the user's authentication state.
 *
 * Structural Segregation:
 *  - User profiles are stored in a separate, private collection (/users/{userId}) to
 *    ensure privacy and prevent accidental data leakage.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows only the owning user to read and write their own profile data.
     * @path /users/{userId}
     * @allow (get, create, update, delete) if the user is signed in and the requested userId matches their own UID.
     *   Example: A user with UID 'user123' can read/write the document /users/user123.
     * @deny (get, create, update, delete) if the user is not signed in, or the requested userId does not match their own UID.
     *   Example: A user with UID 'user123' cannot read/write the document /users/user456.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get: if isOwner(userId);
      allow list: if false; // No listing of users for privacy.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && resource.data.id == userId;
      allow delete: if isOwner(userId);
    }

    /**
     * @description Allows any authenticated user to read and write asset data.
     * @path /assets/{assetId}
     * @allow (get, list) if true; (create, update, delete) if the user is signed in.
     *   Example: Any signed-in user can create, update, or delete an asset.
     * @deny No specific denial conditions.
     * @principle Allows public read access with authenticated writes.
     */
    match /assets/{assetId} {
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null;
      allow delete: if isSignedIn() && resource != null;
    }

    /**
     * @description Allows any authenticated user to read and write category data.
     * @path /categories/{categoryId}
     * @allow (get, list) if true; (create, update, delete) if the user is signed in.
     *   Example: Any signed-in user can create, update, or delete a category.
     * @deny No specific denial conditions.
     * @principle Allows public read access with authenticated writes.
     */
    match /categories/{categoryId} {
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null;
      allow delete: if isSignedIn() && resource != null;
    }

    /**
     * @description Allows any authenticated user to read and write location data.
     * @path /locations/{locationId}
     * @allow (get, list) if true; (create, update, delete) if the user is signed in.
     *   Example: Any signed-in user can create, update, or delete a location.
     * @deny No specific denial conditions.
     * @principle Allows public read access with authenticated writes.
     */
    match /locations/{locationId} {
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null;
      allow delete: if isSignedIn() && resource != null;
    }

    /**
     * @description Allows any authenticated user to read and write history log data.
     * @path /history/{historyId}
     * @allow (get, list) if true; (create, update, delete) if the user is signed in.
     *   Example: Any signed-in user can create, update, or delete a history entry.
     * @deny No specific denial conditions.
     * @principle Allows public read access with authenticated writes.
     */
    match /history/{historyId} {
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null;
      allow delete: if isSignedIn() && resource != null;
    }
  }
}